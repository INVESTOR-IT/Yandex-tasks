# Задача "Ян в качалке"

В тренажёрном зале в ряд стоят N свободных беговых дорожек. Ян и K его друзей решили сегодня сходить позаниматься.<br>
Чтобы не мешать друг другу заниматься спортом, они договорились занимать дорожки максимально далеко друг от друга.<br> 
Каждый из ребят выбирает дорожку в центре самого большого свободного участка.<br>
Так как ребята тратят разное время на подготовку к тренировке, они занимают тренажеры поочередно.

Каждый из ребят выбирает такую дорожку, для которой будет максимально минимальное расстояние<br>
до занятых дорожек слева и справа.<br>
Если таких дорожек несколько, то случайным образом Яном выбирается одна из них.<br>
Однако, если крайние беговые дорожки все еще свободны, то предпочтение отдается именно им.

К сожалению, Ян довольно нерасторопный и пришел в зал последним (он не очень быстро переодевается).<br>
По данным числам N и K определите, сколько дорожек осталось свободными с двух сторон от Яна<br>
после того, как он займет свою дорожку (K + 1-ым по счёту).

<br>

## Формат ввода
Программа принимает на вход два натуральных числа N и K, где 1 ⩽ K < N ⩽ 10 ** 18.

<br>

## Формат вывода
Программа должна вывести два натуральных числа в порядке неубывания,<br>
представляющие количество свободных дорожек с двух сторон от Яна.

<br>

/          | input  | output
| -------- | ------ | ------ |
| Пример 1 | 7 0    | 0 6    |
| Пример 2 | 7 1    | 0 5    |
| Пример 3 | 8 2    | 2 3    |
| Пример 4 | 8 3    | 1 1    |

<br>

### Примечания
В первом примере Ян занял самую крайнюю дорожку. С одной стороны не было ни одной<br>
дорожки, с другой были оставшиеся N − 1 дорожка.

Во втором примере Ян опять занял самую крайнюю дорожку, но уже с другой стороны.

В третьем примере Ян выбрал одну из двух дорожек с равным суммарных расстоянием до левой и правой занятой дорожки.

---

<br>

# Решение

Представим наши беговые дорожки в виде списка, где каждый элемент, это номер дорожки

```Python
[0, 1, 2, 3, 4, 5, 6, 7]
```
<br>

Соблюдая условия, первое, что приходит в голову, это занять сначало крайние стороны (0 и 7 индекс)<br>

Создадим функцию, где будем через цикл `for` закрвать свободные дорожки<br>
Иитерируемся по количеству друзей Яна + 1 (сам Ян)<br>
Закрываем наши крайние индексы через `if`<br>
Итог
```Python
[None, 1, 2, 3, 4, 5, 6, None]
```
<br>

Теперь представим что крайние дорожки заняты, а друзей было 3 человека<br>
Что мы сделаем в ситуации последнего друга?<br>
Возьмем область свободных дорожек, поделим на два и получим индекс нужной дорожки по условию задачи
```Python
slice_tracks = [1, 2, 3, 4, 5, 6]
index = slice_tracks[len(slice_tracks) // 2]
```
<br>

Меняем нужный нам индекс на `None` и получаем следующее:
```Python
[None, 1, 2, 3, None, 5, 6, None]
```
<br>

А теперь представим, что мы на месте Яна, что мы сделаем?<br>
Тоже что и последнйи друг, определим все области свободных дорожек, выберим самую большую и делим на два

```Python
slice_tracks = [[]]                             # Создали список с первой областью

for i in tracks[1:-1]:
    if i is None:               
        slice_tracks.append([])                 # Если дорожка занята, создаем новую область
        continue
    slice_tracks[-1].append(i)                  # Добавляем индекс свободной дорожки в нашу область

slice_tracks = max(slice_tracks, key=len)       # Выбираем самую длинную область
index = slice_tracks[len(slice_tracks) // 2]    # Находим индекс нашей дорожки
tracks[index] = None                            # Занимаем эту дорожку
```
<br>

И вот Ян нашел себе место на дорожке соблюдая все правила<br>
Теперь определим сколько слева и справа от него осталось свободных дорожек<br>

Создадим функцию, где сначала от последнего индекса (там наш Ян) считаем сколько слева свободных дорожек<br>
После считаем сколь српава от Яна свободных дорожек<br>

Финал, результат сортеруем и выводим в терминал 

<br>


# Решение 2

Смысл остается такой же, изменил только подход поиска областей с свободными дорожками<br>
Вместо цикла `for` использовал `itertools.groupby`, но понадобился списочный генератор для нужного результата<br>
Был в поиске убрать О(n ** 2)

В файле `first_solution.py` первое решение<br>
В файле `second_solution.py` второе решение<br>
В файле `comparison.py` сравниваю два решения<br>

Результат сравнения показал, что на маленьких числах оба решения +- быстро работают<br>
С большими числами второе решение начинает проседать аж в два раза, в принципе логично, я же добавил сложность<br>

Оставил пощупать два варианта, вдруг у кого будет идея на основе моих решений<br>
Всем добра!
